왜 질의어가 필요하는가? 정확한 표현을위해 구조적인 질의어 필요
표준언어 사용시 : 교육비용절감, 생산성증가, 이식성 향상 ,DBMS의존도 줄어듬

SQL은 비절차적인언어 : 원하는 데이터만 명시하고 처리하는방법은 명시할수없다.
관계대수는 절차적언어이다

SQL	인터페이스 : 대화식 SQL , 내포된SQL
	구성요소 : 데이터검색,데이터 조작어, 데이터정의어,트랜젝션제어,데이터제어

create schema my_db authorization kim;
drop schema my_db;
create table EMP(empno number not null,
	primary key(empno),
	foreign key (manager) references employee(empno));

제약조건 not null, unique, default, check
기본키 제약조건 : not null 기본키는 자동적 인덱스 생성
참조 무결성 제약조건 : 참조되는 애트리뷰트는 동일한 데이터타입가지면서 Unique,또는 기본키
ON DELETE NO ACTION -> 기본값
ON DELETE CASCADE
ON DELETE SET NULL
ON DELETE SET DEFAULT

distinct
alias

중첩질의
상관 중첩 질의

update R set A="";

DB 설계 과정 : 라이프사이클
1.요구분석
2.개념적설계 :ER설계
-----DBMS 독집적----------
3. 논리적 설계 : DB스키마사상
4.정규화
5. 물지적설계 : 인덱스설정
6. 보안설계
7. 구현

DB설계 : 중복 최소화 무결성,일관성
DBMS 선정 : 기술적인요인 데이터모델,저장구조,인터페이스... 경제적요인 하드웨어 구입비용 ,유지보수,교육...

ER모델 :
엔티티 타임 : 내포 , 엔티티집합 : 외연
강한엔티티 타입: 기본키를 가진 엔티티 :(정규 엔티티타입)
약한엔티티 타입 : 기본키가 없는 엔티티 ,소유엔티티를 가진다 ( 소유엔티티,식별엔티티)
의존종속성 : 약한엔티티는 강한 엔티티에게 종속되는것

레코드 = 투플
레코드 모임 = 화일

신장된 레코드 : 한레코드를 두개이상의 블록저장
BLOB : 대규모 크기의 데이터 저장 하는데 사영
채우기 인수 : 블록에 레코드를 채우는 공간의 비율
화일내의 클러스터링 : 한 화일내에서 함께 검색될 가능성이 높은 레코드를 물리적으로 가까이 두는것
화일 간의 클러스터링 : 논리적으로 연관되어 함계 검색될 가능성이 높은 두개 이상의 화일에 속한 레코드들을 디스크상에서 물리적으로 가까운곳에 저장
화일간의 클러스터링이 조인성능은 좋지만 탐색,삽입,삭제,수정은 느림

히프파일 :삽입된 순서대로 저장, 순차적으로 모두 탐색요구 
한꺼번에 적재할때,몇개의 블럭만있을대 검색위주로 사용될떄 사용
삽입에 효율적
블로킹 인수 : 한블럭에 포함되는 레코드수

순차파일 : 하나이상의 필드값에 따라 순서대로 저장 이진탐색이 가능하여 탐색시간이 효율적
단일단계 인덱스 : 인덱스의 크기는 데이터화일크기의 10%-20%
탐색키 : 인덱스가 정의된 필드

기본인덱스 : 탐색키가 화일의 기본키인 인덱스 일반적으로 블록내의 첫번째 레코드의 키값을 가진다
클러스터링인덱스 : 탐색키 값에 따라 정렬된 데이터 화일에 대해 정의

